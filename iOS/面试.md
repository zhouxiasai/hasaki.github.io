- 停车问题
- 工作时间（打卡 996）
- 团队大小

做一个APP，大的架构是通用的，代码规范、容错处理，小的模块的使用 可以临时学都来得及。

# 组件化

基础功能组件、基础UI组件、产品业务组件。

### Mediator

我们的项目是用 组件化的方式进行架构设计，以达到解耦不同业务模块的代码的目的，具体实现方式是：
用一个 Mediator 类作为中间件的进行组件间的动态调度，把需要暴露给别人用的功能，封装成接口供别人调用，这些对外开放的接口统一放到 Mediator 的 Category 中，由接口提供方自行维护。

Mediator 调度的关键在于 Runtime 反射（将字符串转换为特定的类、方法、属性），所以，Mediator 内部维护了一套反射规则（其实就是命名规则），目前我们的规则是 Target Action， Target 前缀用于定义需要调度的类名，Action 前缀用于定义需要执行的方法名，参数和返回值通过 NSInvocation 进行传递。这套反射规则我们目前写在 .h 中，后续会在这个 repo 中专门维护一个文档。

category 的目的主要就是代码隔离，让 Mediator 只做动态调度的功能，暴露给别人的接口中，具体调用的类名、方法名、参数表都由 category 进行维护和规范。

Mediator 同样可以响应远程的 url 调用。做法就是：
`scheme://[target]/[action]?[params]`
定义一套 url 规则，比如，url 的 host 部分定义为需要调用的类名，path 部分定义为方法名，query 部分作为参数进行传递。（scheme部分当然是 APP 标识，用于别的 APP 跳转）。将这个 url 进行解析后，其实就是之前的本地调用的做法了。同样，url 规则也需要维护一份文档。

这是最简单的实现方式，后期可以自己添加 url 的加解密规则。

对于无法响应的 url 或者本地组件调用，可以在接口提供方做第一层的处理，如果提供方无法处理，则由 Mediator 统一进行处理。

### URL 路由

看过蘑菇街 limboy 的博客，对 URL 路由也有初步的了解。

首先，有一个 Router 单例类，作为组件的注册表常驻于内存中。各组件用 url 表示接口，在模块启动时，通过 Router 类的注册方法把需要暴露给别人用的功能通过 URL + block 的形式注册到表中。此方案需要单独维护一份 URL 列表及参数列表。

使用方在使用时传入对应的 url 及参数来调用别的模块的功能。

优缺点：

URL 路由需要在内存维护一份注册表，造成内存常驻；Mediator 使用 Runtime 运行时生成相关类。
URL 传输的参数类型有限制，只能传递基本数据类型。
如果提供方注册的 URL 改动了，那么所有调用的地方都需要进行改动。


都使用去model化的设计，降低耦合性，但是会增加一定的维护成本。



### 事件传递

UIApplication → keywindow → 从subview 中从后向前递归遍历。